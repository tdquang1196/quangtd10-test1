# Project Architecture Documentation

## Overview

This project follows **Clean Architecture** and **Domain-Driven Design (DDD)** principles to ensure maintainability, testability, and scalability.

## Architecture Layers

```
┌─────────────────────────────────────────────────────────────┐
│                    Presentation Layer                         │
│  (UI Components, Pages, Hooks)                               │
│  - app/                                                      │
│  - components/                                               │
│  - hooks/                                                    │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                   Application Layer                          │
│  (Use Cases, DTOs, Business Workflows)                      │
│  - src/application/use-cases/                               │
│  - src/application/dtos/                                    │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                     Domain Layer                             │
│  (Entities, Value Objects, Repository Interfaces)           │
│  - src/domain/user-management/entities/                     │
│  - src/domain/user-management/value-objects/                │
│  - src/domain/user-management/repositories/                 │
│  - src/domain/shared/                                       │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                 Infrastructure Layer                         │
│  (External Services, API Clients, Database)                 │
│  - src/infrastructure/repositories/                         │
│  - src/infrastructure/api/                                  │
└─────────────────────────────────────────────────────────────┘
```

## Folder Structure

```
project/
├── src/                                # Business logic (Clean Architecture)
│   ├── domain/                        # Domain layer (Core business logic)
│   │   ├── user-management/          # User management bounded context
│   │   │   ├── entities/             # Domain entities
│   │   │   │   ├── User.ts          # User entity with business rules
│   │   │   │   └── Class.ts         # Class entity
│   │   │   ├── value-objects/       # Immutable value objects
│   │   │   │   ├── Username.ts      # Username generation & validation
│   │   │   │   ├── DisplayName.ts   # Display name logic
│   │   │   │   ├── Password.ts      # Password generation
│   │   │   │   └── ClassName.ts     # Class name formatting
│   │   │   └── repositories/        # Repository interfaces
│   │   │       ├── IUserRepository.ts
│   │   │       └── IClassRepository.ts
│   │   └── shared/                  # Shared domain concepts
│   │       └── Result.ts            # Result pattern for error handling
│   │
│   ├── application/                  # Application layer (Use cases)
│   │   ├── use-cases/               # Business use cases
│   │   │   ├── ProcessExcelFile.ts # Excel processing use case
│   │   │   └── MigrateUsers.ts     # User migration orchestration
│   │   └── dtos/                   # Data Transfer Objects
│   │       └── UserMigrationDTO.ts
│   │
│   └── infrastructure/              # Infrastructure layer
│       ├── repositories/           # Repository implementations
│       │   └── HttpUserRepository.ts
│       └── api/                    # API clients
│
├── app/                            # Next.js app directory (Presentation)
│   ├── page.tsx                   # Features hub homepage
│   ├── features/                  # Feature pages
│   │   └── user-migration/
│   │       └── page.tsx
│   └── api/                       # API routes
│       └── migrate/
│           └── route.ts
│
├── components/                     # React components (Presentation)
│   ├── ui/                        # Reusable UI components
│   │   ├── Button.tsx
│   │   ├── Card.tsx
│   │   ├── Badge.tsx
│   │   ├── Input.tsx
│   │   ├── Table.tsx
│   │   └── FeatureCard.tsx
│   ├── migration/                 # Migration feature components
│   │   ├── MigrationModal.tsx
│   │   ├── UploadTab.tsx
│   │   ├── PreviewTab.tsx
│   │   └── ResultsTab.tsx
│   └── Notification.tsx
│
├── hooks/                         # Custom React hooks
│   └── useMigration.ts
│
├── types/                         # TypeScript type definitions
│   └── index.ts
│
├── constants/                     # Application constants
│   └── features.ts
│
├── config/                        # Configuration files
│   └── equipment.ts
│
└── utils/                         # Utility functions
    └── bulkRegistrationUtils.ts
```

## Design Patterns

### 1. **Domain-Driven Design (DDD)**

#### Entities
- `User`: Represents a user with identity and business rules
- `Class`: Represents a class/group

**Example:**
```typescript
const user = User.create({
  username: 'testuser',
  displayName: 'Test User',
  password: '1234',
  role: 'student',
  className: 'CLASS_1A_2025'
})

user.updateDisplayName('New Name') // Business logic encapsulated
```

#### Value Objects
Immutable objects defined by their values:
- `Username`: Handles username generation and validation
- `DisplayName`: Manages display name logic
- `Password`: Generates and validates passwords
- `ClassName`: Formats class names

**Example:**
```typescript
const username = Username.generate('Nguyễn Văn A', 'hytkltt')
// Returns: Username with value 'hytklttannv'

const password = Password.generateRandom()
// Returns: Password with 4-digit random value
```

#### Repository Pattern
Abstracts data access logic:

**Interface (Domain):**
```typescript
interface IUserRepository {
  register(user: User): Promise<Result<User>>
  existsByUsername(username: string): Promise<Result<boolean>>
}
```

**Implementation (Infrastructure):**
```typescript
class HttpUserRepository implements IUserRepository {
  async register(user: User): Promise<Result<User>> {
    // HTTP implementation
  }
}
```

### 2. **Result Pattern**

Explicit error handling without exceptions:

```typescript
const result = await userRepository.register(user)

if (result.isSuccess) {
  console.log('User:', result.value)
} else {
  console.error('Error:', result.error)
}

// Or using match
result.match(
  user => console.log('Success:', user),
  error => console.error('Failed:', error)
)
```

### 3. **Use Case Pattern**

Each business operation is a separate use case:

```typescript
class ProcessExcelFile {
  execute(rows: ExcelRowDTO[], schoolPrefix: string): Result<ProcessExcelResultDTO> {
    // Business logic here
  }
}

class MigrateUsers {
  async execute(request: MigrationRequestDTO): Promise<Result<MigrationResultDTO>> {
    // Migration orchestration
  }
}
```

## Bounded Contexts

### User Management
Responsible for user-related operations:
- User registration
- Display name management
- Equipment assignment
- Class assignment

**Domain Model:**
- Entities: User, Class
- Value Objects: Username, DisplayName, Password, ClassName
- Repositories: IUserRepository, IClassRepository

## Data Flow

### User Migration Flow

```
1. User uploads Excel file
   ↓
2. ProcessExcelFile Use Case
   - Validates data
   - Creates domain objects (Username, DisplayName, etc.)
   - Returns StudentDTO[] and TeacherDTO[]
   ↓
3. MigrateUsers Use Case
   - Authenticates as admin
   - For each user:
     * Create User entity
     * Check username availability (Repository)
     * Register user (Repository)
     * Login as user
     * Set display name
     * Assign equipment
   ↓
4. Return MigrationResultDTO
   - Success list
   - Error list with reasons
```

## Benefits of This Architecture

### 1. **Separation of Concerns**
- Domain logic is independent of UI
- Business rules in one place
- Easy to test domain logic

### 2. **Maintainability**
- Clear structure
- Each layer has specific responsibility
- Easy to locate and modify code

### 3. **Testability**
- Domain entities can be tested in isolation
- Use cases can be tested without UI
- Repositories can be mocked

### 4. **Flexibility**
- Easy to swap implementations (e.g., HTTP → GraphQL)
- UI framework can be changed without affecting business logic
- Database can be changed without modifying domain

### 5. **Scalability**
- New features follow same structure
- Easy to add new bounded contexts
- Clear guidelines for team members

## Adding New Features

### Step 1: Define Domain
1. Create entities in `src/domain/[context]/entities/`
2. Create value objects in `src/domain/[context]/value-objects/`
3. Define repository interfaces in `src/domain/[context]/repositories/`

### Step 2: Create Use Cases
1. Define DTOs in `src/application/dtos/`
2. Implement use cases in `src/application/use-cases/`

### Step 3: Implement Infrastructure
1. Implement repositories in `src/infrastructure/repositories/`
2. Create API clients if needed

### Step 4: Build UI
1. Create components in `components/`
2. Create pages in `app/`
3. Use hooks to connect UI to use cases

## Example: Adding "Data Export" Feature

```typescript
// 1. Domain
src/domain/data-export/
  entities/
    ExportJob.ts
  value-objects/
    ExportFormat.ts
  repositories/
    IExportRepository.ts

// 2. Application
src/application/
  dtos/
    DataExportDTO.ts
  use-cases/
    ExportUsersToExcel.ts
    ExportUsersToCSV.ts

// 3. Infrastructure
src/infrastructure/
  repositories/
    FileExportRepository.ts

// 4. Presentation
app/features/data-export/
  page.tsx
components/export/
  ExportModal.tsx
```

## Best Practices

1. **Keep domain pure** - No dependencies on external libraries
2. **Use Result pattern** - Avoid throwing exceptions
3. **Validate in entities** - Business rules in domain entities
4. **Thin use cases** - Orchestrate, don't implement
5. **Depend on abstractions** - Use interfaces, not implementations
6. **Test domain first** - Start with entity and value object tests

## Migration from Old Structure

Old → New mapping:

| Old | New |
|-----|-----|
| `utils/bulkRegistrationUtils.ts` | `src/application/use-cases/ProcessExcelFile.ts` |
| `lib/migrationService.ts` | `src/application/use-cases/MigrateUsers.ts` |
| `types/index.ts` (interfaces) | `src/application/dtos/` |
| Business logic in components | `src/domain/` entities and value objects |
| Direct API calls in hooks | `src/infrastructure/repositories/` |

## Resources

- **Clean Architecture**: Robert C. Martin
- **Domain-Driven Design**: Eric Evans
- **Value Objects**: Martin Fowler
- **Repository Pattern**: Patterns of Enterprise Application Architecture
