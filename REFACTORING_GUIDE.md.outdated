# Refactoring Guide

## What Changed?

Your project has been refactored from a **basic structure** to a **professional, enterprise-grade architecture** following Clean Architecture and Domain-Driven Design principles.

## Before & After

### Before (Basic Structure)
```
â”œâ”€â”€ app/
â”œâ”€â”€ components/
â”œâ”€â”€ hooks/
â”œâ”€â”€ lib/
â”œâ”€â”€ utils/
â””â”€â”€ types/
```
**Problems:**
- Business logic mixed with UI
- No clear separation of concerns
- Hard to test
- Difficult to maintain as project grows

### After (Clean Architecture)
```
â”œâ”€â”€ src/                    # Business logic layer
â”‚   â”œâ”€â”€ domain/            # Core business rules
â”‚   â”œâ”€â”€ application/       # Use cases
â”‚   â””â”€â”€ infrastructure/    # External services
â”œâ”€â”€ app/                   # Presentation (UI)
â”œâ”€â”€ components/
â””â”€â”€ hooks/
```
**Benefits:**
- Clear separation of concerns
- Highly testable
- Easy to maintain and extend
- Framework-independent business logic

## Key Concepts

### 1. Domain Layer (Core Business Logic)

**Entities** - Objects with identity and business rules:
```typescript
// User entity with validation
const user = User.create({
  username: 'testuser',
  displayName: 'Test User',
  password: '1234',
  role: 'student',
  className: 'CLASS_1A_2025'
})

// Business methods
user.updateDisplayName('New Name')
user.updatePhoneNumber('0123456789')
```

**Value Objects** - Immutable objects defined by values:
```typescript
// Username generation with business rules
const username = Username.generate('Nguyá»…n VÄƒn A', 'hytkltt')
// Output: 'hytklttannv' (auto-normalized, validated)

// Random password generation
const password = Password.generateRandom()
// Output: '7382' (4-digit random)

// Display name extraction
const displayName = DisplayName.generate('Nguyá»…n VÄƒn An')
// Output: 'VÄƒn An' (last 2 words, max 20 chars)
```

### 2. Repository Pattern

**Abstraction for data access:**
```typescript
// Interface (in domain)
interface IUserRepository {
  register(user: User): Promise<Result<User>>
  existsByUsername(username: string): Promise<Result<boolean>>
}

// Implementation (in infrastructure)
class HttpUserRepository implements IUserRepository {
  async register(user: User): Promise<Result<User>> {
    const response = await this.httpClient.post('/api/v1/auth/register', {
      userName: user.username,
      password: user.password
    })
    // ...
  }
}
```

### 3. Use Cases (Business Workflows)

**Each business operation is a use case:**
```typescript
// Process Excel File
const processExcel = new ProcessExcelFile()
const result = processExcel.execute(excelRows, schoolPrefix)

if (result.isSuccess) {
  const { students, teachers, errors } = result.value
  // Use the processed data
}

// Migrate Users
const migrateUsers = new MigrateUsers(userRepo, classRepo, config)
const migrationResult = await migrateUsers.execute(request)
```

### 4. Result Pattern (Error Handling)

**No more try-catch everywhere:**
```typescript
// Old way (throwing exceptions)
try {
  const user = await createUser(data)
  console.log(user)
} catch (error) {
  console.error(error)
}

// New way (Result pattern)
const result = await userRepository.register(user)

if (result.isSuccess) {
  console.log('User:', result.value)
} else {
  console.error('Error:', result.error)
}

// Or use match
result.match(
  user => handleSuccess(user),
  error => handleError(error)
)
```

## How to Use the New Structure

### Example 1: Processing Excel File

**Old way:**
```typescript
// Business logic mixed with component
const handleProcess = () => {
  const parts = fullName.split(' ')
  const lastName = parts[parts.length - 1]
  // ... lots of logic in component
}
```

**New way:**
```typescript
// Use case handles all logic
import { ProcessExcelFile } from '@/src/application/use-cases/ProcessExcelFile'

const processExcel = new ProcessExcelFile()
const result = processExcel.execute(excelRows, schoolPrefix)

if (result.isSuccess) {
  const { students, teachers } = result.value
  setStudents(students)
  setTeachers(teachers)
} else {
  showError(result.error)
}
```

### Example 2: Migrating Users

**Old way:**
```typescript
// API calls scattered in hook/component
const migrateUsers = async () => {
  const response = await axios.post('/api/migrate', data)
  // ... complex logic
}
```

**New way:**
```typescript
// Use case orchestrates everything
import { MigrateUsers } from '@/src/application/use-cases/MigrateUsers'
import { HttpUserRepository } from '@/src/infrastructure/repositories/HttpUserRepository'

const userRepo = new HttpUserRepository(API_URL)
const migrateUsers = new MigrateUsers(userRepo, classRepo, {
  adminUsername: process.env.ADMIN_USERNAME,
  adminPassword: process.env.ADMIN_PASSWORD
})

const result = await migrateUsers.execute(requestDTO)
```

## Folder Structure Explained

### `/src/domain/` - Business Rules (Core)

**What goes here:**
- Entities with business logic
- Value objects for data validation
- Repository interfaces
- Domain events
- Shared domain concepts

**Example structure:**
```
src/domain/
â”œâ”€â”€ user-management/          # Bounded context
â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”œâ”€â”€ User.ts          # User with business rules
â”‚   â”‚   â””â”€â”€ Class.ts         # Class entity
â”‚   â”œâ”€â”€ value-objects/
â”‚   â”‚   â”œâ”€â”€ Username.ts      # Username logic
â”‚   â”‚   â”œâ”€â”€ DisplayName.ts   # Display name logic
â”‚   â”‚   â””â”€â”€ Password.ts      # Password generation
â”‚   â””â”€â”€ repositories/
â”‚       â””â”€â”€ IUserRepository.ts  # Interface only
â””â”€â”€ shared/
    â””â”€â”€ Result.ts            # Shared patterns
```

**Rules:**
- âœ… Pure TypeScript/JavaScript
- âœ… No external dependencies (except maybe utility libs)
- âœ… No framework code
- âŒ No React components
- âŒ No API calls
- âŒ No database code

### `/src/application/` - Use Cases (Orchestration)

**What goes here:**
- Use cases (business workflows)
- DTOs (Data Transfer Objects)
- Application services

**Example:**
```
src/application/
â”œâ”€â”€ use-cases/
â”‚   â”œâ”€â”€ ProcessExcelFile.ts     # Excel processing workflow
â”‚   â”œâ”€â”€ MigrateUsers.ts          # Migration orchestration
â”‚   â””â”€â”€ ExportUsersToExcel.ts   # Export workflow
â””â”€â”€ dtos/
    â”œâ”€â”€ UserMigrationDTO.ts      # Data structures
    â””â”€â”€ ExportDTO.ts
```

**Rules:**
- âœ… Orchestrates domain entities
- âœ… Calls repositories
- âœ… Returns DTOs
- âŒ No UI code
- âŒ No HTTP/database implementation

### `/src/infrastructure/` - External Services

**What goes here:**
- Repository implementations
- API clients
- Database access
- File system operations
- Third-party service integrations

**Example:**
```
src/infrastructure/
â”œâ”€â”€ repositories/
â”‚   â”œâ”€â”€ HttpUserRepository.ts    # HTTP implementation
â”‚   â””â”€â”€ HttpClassRepository.ts
â””â”€â”€ api/
    â””â”€â”€ ApiClient.ts
```

**Rules:**
- âœ… Implements repository interfaces
- âœ… Makes API calls
- âœ… Handles external services
- âŒ No business logic

### `/app/` & `/components/` - Presentation Layer

**What goes here:**
- React components
- Pages
- UI logic
- Hooks that connect to use cases

**Rules:**
- âœ… UI components
- âœ… Call use cases
- âœ… Display data
- âŒ No business logic
- âŒ Minimal data transformation

## Migration Path

### Current Files Mapping

| Old Location | New Location | Status |
|-------------|--------------|--------|
| `utils/bulkRegistrationUtils.ts` | `src/application/use-cases/ProcessExcelFile.ts` | âœ… Created |
| `lib/migrationService.ts` | `src/application/use-cases/MigrateUsers.ts` | âœ… Created |
| Types in `types/index.ts` | `src/application/dtos/UserMigrationDTO.ts` | âœ… Created |
| Business logic in hooks | `src/domain/*/entities/` & value objects | âœ… Created |

### What to Keep

**Keep these (still valid):**
- âœ… `app/` - Next.js pages
- âœ… `components/ui/` - Reusable UI components
- âœ… `components/migration/` - Feature components
- âœ… `hooks/useMigration.ts` - Can update to use new use cases
- âœ… `constants/features.ts` - Configuration
- âœ… `config/equipment.ts` - Configuration

**Can gradually migrate:**
- ğŸ”„ Update `hooks/useMigration.ts` to use new use cases
- ğŸ”„ Update `app/api/migrate/route.ts` to use new use cases

## Adding New Features (Step by Step)

### Example: Add "User Search" Feature

**Step 1: Define Domain**
```typescript
// src/domain/user-management/value-objects/SearchCriteria.ts
export class SearchCriteria {
  constructor(
    private readonly query: string,
    private readonly filters: SearchFilters
  ) {
    this.validate()
  }

  private validate() {
    if (this.query.length < 2) {
      throw new Error('Search query must be at least 2 characters')
    }
  }
}
```

**Step 2: Add Repository Method**
```typescript
// src/domain/user-management/repositories/IUserRepository.ts
interface IUserRepository {
  // ... existing methods
  search(criteria: SearchCriteria): Promise<Result<User[]>>
}
```

**Step 3: Implement Repository**
```typescript
// src/infrastructure/repositories/HttpUserRepository.ts
async search(criteria: SearchCriteria): Promise<Result<User[]>> {
  const response = await this.httpClient.get('/api/v1/users/search', {
    params: { q: criteria.getQuery() }
  })
  // ... implementation
}
```

**Step 4: Create Use Case**
```typescript
// src/application/use-cases/SearchUsers.ts
export class SearchUsers {
  constructor(private userRepository: IUserRepository) {}

  async execute(query: string, filters: any): Promise<Result<UserDTO[]>> {
    const criteria = SearchCriteria.create(query, filters)
    const result = await this.userRepository.search(criteria)

    if (result.isFailure) {
      return Result.fail(result.error)
    }

    const userDTOs = result.value.map(user => ({
      id: user.id,
      username: user.username,
      displayName: user.displayName
    }))

    return Result.ok(userDTOs)
  }
}
```

**Step 5: Use in Component**
```typescript
// components/UserSearch.tsx
const handleSearch = async () => {
  const searchUsers = new SearchUsers(userRepository)
  const result = await searchUsers.execute(query, filters)

  if (result.isSuccess) {
    setUsers(result.value)
  } else {
    showError(result.error)
  }
}
```

## Testing

### Domain Layer Tests (Pure Logic)
```typescript
// __tests__/domain/Username.test.ts
describe('Username', () => {
  it('should generate username from Vietnamese name', () => {
    const username = Username.generate('Nguyá»…n VÄƒn A', 'hytkltt')
    expect(username.getValue()).toBe('hytklttannv')
  })

  it('should throw error for invalid length', () => {
    expect(() => Username.create('abc')).toThrow()
  })
})
```

### Use Case Tests (Business Workflows)
```typescript
// __tests__/application/ProcessExcelFile.test.ts
describe('ProcessExcelFile', () => {
  it('should process valid Excel data', () => {
    const useCase = new ProcessExcelFile()
    const result = useCase.execute(validRows, 'hytkltt')

    expect(result.isSuccess).toBe(true)
    expect(result.value.students.length).toBe(10)
  })
})
```

## Best Practices

### âœ… DO

1. **Keep domain pure** - No dependencies on frameworks
2. **Use Result pattern** - Explicit error handling
3. **Create value objects** - For validation and business rules
4. **Write use cases** - One per business operation
5. **Depend on interfaces** - Not implementations
6. **Test domain first** - Easiest to test

### âŒ DON'T

1. **Don't put business logic in components** - Use use cases
2. **Don't call APIs directly from hooks** - Use repositories
3. **Don't throw exceptions everywhere** - Use Result pattern
4. **Don't create anemic entities** - Add behavior to entities
5. **Don't skip validation** - Validate in domain entities
6. **Don't mix layers** - Respect dependencies

## Quick Reference

### When to create an Entity?
When the object has:
- Identity (ID)
- Lifecycle
- Business rules
- Mutable state

Example: User, Class, Order

### When to create a Value Object?
When the object:
- Has no identity
- Is immutable
- Is defined by its values
- Can be easily replaced

Example: Username, Email, Money, Address

### When to create a Use Case?
For each business operation:
- Process Excel File
- Migrate Users
- Export Data
- Search Users
- Update Profile

### When to create a Repository?
For each aggregate root:
- UserRepository (User entity)
- ClassRepository (Class entity)
- OrderRepository (Order entity)

## Next Steps

1. âœ… **Structure created** - Domain, Application, Infrastructure layers
2. ğŸ“ **Update existing code** - Gradually migrate to use new structure
3. ğŸ§ª **Add tests** - Start with domain entities and value objects
4. ğŸ“š **Read documentation** - See `ARCHITECTURE.md` for details
5. ğŸš€ **Extend** - Add new features following the same pattern

## Questions?

**Q: Do I have to migrate everything now?**
A: No! Keep existing code working. Gradually adopt new structure for new features.

**Q: Can I still use the old files?**
A: Yes! Old files (utils/, lib/) still work. New structure is additive.

**Q: Is this overkill for a small project?**
A: The structure scales. Start small, patterns remain the same as you grow.

**Q: How do I test this?**
A: Domain and use cases are pure functions, very easy to test without mocking UI.
